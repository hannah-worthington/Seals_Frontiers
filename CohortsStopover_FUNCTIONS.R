### Likelihood function

### Function to evaluate the negative log-likelihood of the multiple cohort stopover model in the HMM framework

# Name: likelihood_cohort
# Objective: To evaluate the negative log-likelihood of the multiple cohort HMM given a set of parameter values and capture histories
# Inputs: param - model specific, will be passed to other functions for structuring
#         X - capture histories, a matrix for each cohort stored in a list
#         arr.dist - distribution on arrivals, type and number of mixtures
#         arr.str - structure for arrivals (shared or cohort)
#         min.age - minimum age of return (default = 3)
# Outputs: lik - negative log-likelihood value

likelihood_cohort <- function(param, X, arr.dist, arr.str, min.age = 3)  {
  
  print(param)
  
  # define constants
  n.cohorts <- length(X)  # number of cohorts
  n <- rep(0, n.cohorts)  # number of individuals in each cohort
  K <- rep(0, n.cohorts)  # number of capture occasions for each cohort
  for (c in 1:n.cohorts)  {
    n[c] <- length(data[[c]][,1])
    K[c] <- length(data[[c]][1,])
  }
  
  # unpack the parameter vector
  param_function <- match.fun(arr.dist)
  params <- param_function(param, arr.str, min.age, n.cohorts, K)
  HMM <- HMM.str(params, n.cohorts, K)
  
  # storage variables
  lik.cohort <- rep(0, n.cohorts)
  
  # loop over cohorts evaluating likelihood for single cohort
  for (c in 1:n.cohorts)  {
    lik.partial <- 0
    # loop over individuals
    for (i in 1:n[c])  {
      contrib <- HMM$pione[[c]]
      # loop over occasions
      for (k in 1:K[c])  {
        contrib <- contrib %*% HMM$gamma[[c]][,,k]
        contrib <- contrib %*% HMM$pmat[[c]][,,X[[c]][i,k]+1, k]
      }
      # individual contribution
      contrib <- contrib %*% matrix(1, nrow = 3, ncol = 1)
      # add to likelihood for this cohort if nonzero
      if (contrib > 0)  {
        lik.partial <- lik.partial + log(contrib)
      } else if (contrib == 0)  {
        lik.partial <- lik.partial - 10000
      }
    }
    # store likelihood value for cohort, checking for nonzero
    lik.cohort[c] <- lik.partial
  }
  
  # evaluate full likelihood
  lik <- -sum(lik.cohort)
  
  # return
  return(lik)
}



### Function to return the HMM structures given a list of parameters for the cohort stopover model

# Name: HMM.str
# Objective: To take a list of parameters returned from the arr.dist functions and return the HMM structures for use in the likelihood
# Inputs: param - list of parameters generated by the arr.dist functions
#         n.cohorts - the number of cohorts
#         K - number of capture occasions for each cohort
# Outputs: pione - initial state distributions for each cohort
#          gamma - transition probability matrices for each cohort
#          pmat - observation matrices for each cohort

HMM.str <- function(param, n.cohorts, K)  {
  
  # initial state probabilities
  # state probabilities at time 0, year of tagging
  pione <- list()
  for (c in 1:n.cohorts)  {
    pione[[c]] <- c(1, 0, 0)
  }
  
  # transition probability matrices (state, state, occasion)
  gamma <- list()
  for (c in 1:n.cohorts)  {
    gamma[[c]] <- array(0, dim = c(3, 3, K[c]))
    gamma[[c]][1,1,] <- 1 - param$betastar[[c]]
    gamma[[c]][1,2,] <- param$betastar[[c]]
    gamma[[c]][2,2,] <- param$phi
    gamma[[c]][2,3,] <- 1 - param$phi
    gamma[[c]][3,3,] <- 1
  }
  
  # observation matrices (state, state, capture/not, occasion)
  pmat <- list()
  for (c in 1:n.cohorts)  {
    pmat[[c]] <- array(0, dim = c(3, 3, 2, K[c]))
    pmat[[c]][1,1,1,] <- 1
    pmat[[c]][2,2,1,] <- 1-param$p[[c]]
    pmat[[c]][3,3,1,] <- 1
    pmat[[c]][2,2,2,] <- param$p[[c]]
  }
  
  # return
  return(list('pione' = pione, 'gamma' = gamma, 'pmat' = pmat))
}
  


### Functions to unpack the parameter vector

### Function to unpack the parameter vector - normal distribution on arrivals, constant capture, constant survival

# Name: normal_one
# Objective: To unpack and transform a vector of parameter values for the cohort stopover HMM model
# Inputs: param - vector of parameter values, model dependent, order follows:
#               - arrival distribution parameters (mean (log), sd (log))
#               - capture probability (logit)
#               - survival probability (logit)
#         arr.str - arrivals structure, shared or cohort specific (mean, sd)
#         min.age - minimum age of return
#         n.cohorts - number of cohorts
#         K - number of capture occasions for each cohort
# Outputs: mu - mean of arrival distribution for each cohort
#          sd - sd of arrival distribution for each cohort
#          beta - arrival probabilities for each cohort
#          betastar - conditional arrival probabilities for each cohort
#          p - capture probability
#          phi- survival probability

normal_one <- function(param, arr.str, min.age, n.cohorts, K)  {
  
  # mean of arrival distributions
  if (arr.str[1] == 'shared')  {
    means <- rep(exp(param[1]), n.cohorts)
    param <- param[-1]
  } else if(arr.str[1] == 'cohort')  {
    means <- exp(param[1:n.cohorts])
    param <- param[-(1:n.cohorts)]
  }
  
  # sd of arrival distributions
  if (arr.str[2] == 'shared')  {
    sds <- rep(exp(param[1]), n.cohorts)
    param <- param[-1]
  } else if(arr.str[2] == 'cohort')  {
    sds <- exp(param[1:n.cohorts])
    param <- param[-(1:n.cohorts)]
  }
  
  # arrival probabilities
  beta <- list()
  for (c in 1:n.cohorts)  {
    beta[[c]] <- onenormalbetas(means[c], sds[c], K[c], min.age)
  }
  
  # conditional arrival probabilities
  betastar <- list()
  for (c in 1:n.cohorts)  {
    betastar[[c]] <- rep(0, K[c])
    for (k in 1:K[c])  {
      if (sum(beta[[c]][k:K[c]]) > 0)  {
        betastar[[c]][k] <- beta[[c]][k]/sum(beta[[c]][k:K[c]])
      }
    }
  }
  
  # capture probability (constant)
  logitp <- param[1]
  param <- param[-1]
  pnonzero <- 1/(1+exp(-logitp))
  p <- list()
  for (c in 1:n.cohorts)  {
    p[[c]] <- rep(0, K[c])
    p[[c]][min.age:K[c]] <- pnonzero
  }
  
  # retention probability
  phi <- 1/(1+exp(-param))
  
  # return all parameters
  return(list('mu' = means, 'sd' = sds, 'beta' = beta, 'betastar' = betastar, 'p' = p, 'phi' = phi))
}



### Functions to calculate arrival probabilities

### Function to calculate beta probabilities from a normal distribution over the plausible recruitment ages

# Name: onenormalbetas
# Objective: To calculate the beta probabilities from a truncated normal distribution
# Inputs: mu - mean of the arrival distribution
#         sd - sd of the arrival distribution
#         K - number of occasions
#         min.age - minimum age of return
# Outputs: beta - set of beta parameters

onenormalbetas <- function(mu, sd, K, min.age)  {
  
  # storage
  beta <- rep(0, K)
  
  # integrate to find probabilities
  for (k in min.age:K)  {
    beta[k] <- pnorm(k + 0.5, mu, sd) - pnorm(k - 0.5, mu, sd)
  }
  
  # truncating, so reweight the probabilities checking that they are nonzero
  if (sum(beta) > 0)  {
    beta <- beta/sum(beta)
  } else if (sum(beta) == 0 & mu < 0)  {
    beta[1] <- 1
  } else if (sum(beta) == 0 & mu > K)  {
    beta[K] <- 1
  }

  # return the beta probabilities
  return(beta)
}


